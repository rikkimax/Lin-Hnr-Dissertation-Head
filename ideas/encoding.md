## Charactor Encoding
Textual character encoding withing memory has taken many different forms over the span of the IT industry. Common ones have been ASCII, Windows-125x, ISO 8859-x and Unicode (UTF-8, UTF-16 and UTF-32). The standards of HTTP and URI require the usage of ASCII to encoding hostnames and URI paths. However in a world with multitude of langauges that do not fit into the Latin Alphabet as encoded by ASCII, it is necessary to encode other characters. To do this the given characters are encoding using Base64. A common modification for URLs is to generate the characters ``+`` and ``/`` differently by replacing them with ``-`` and ``_`` respectively.

Internally to a web server textual encoding makes for a problematic situation. Decoding must occur before the router attempts perform the routing operation without compomising upon the number of path segments grapheme length. Hostnames do not suffer the same set of problems because of lack of non-ascii values available for use.

To mitigate this issue and allow for non-ascii characters to be encoded and promptly decoded, an alternative solution must be found should the desire to limit memory usage have occured in the developer. If memory limits are not imposed on an implementation then a split + decode per element is an effective measure. However should these limits be imposed then a more complicated measure must occur with using a buffer for the given decoded path part as part of the routing process. In a routing mechanism such as a list based where all path parts should be known ahead of time, the former may be less cpu intensive as the decoding process has occured prior to needing it. For a routing mechanism that utilises validation prior and have all known children at its disposal such as the case of a tree graph then the later option could prove beneficial should the decoded form not need to be passed on to the handler majority of the time. To prevent allocations a per active route set of buffers may be employed in the later of decoding method but it will require significantly more memory allocated and will impose strict limits beyond that of the physical RAM available to the process.

The specific charactor encoding method internal to a router does not matter much as long as it can encode all possible characters that are expected and have a way to encode invalid characters that are received. The size of a code point used is just as non-consequential as the character coding in use. A size of one, two or four bytes cannot encode all graphemes available in the Unicode specification for example. Multiple code points of size four bytes can be required to encode a single grapheme. A router must take this into account and utilize a properly built charactor encoding library. Otherwise the router will fail for some or all of its inputs depending on the combination of character set, charactor encoding and routes defined.